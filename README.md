# goit-algo-hw-06
## Графи

У якості об'єктного графу я згенерував граф залежностей systemd юнітів на робочій ОС свого комп'ютера за допомогою команди `systemd-analyze dot > dependency_graph.dot`. Ви також можете переглянути зображення графу у форматі svg.

Засобами networkx перетворив dependency_graph.dot у структуру данних python. 

Утворений граф містить 203 вузли і 1395 ребер.
Це складний для візуалізації граф, тому я написав функцію format_labels_for_viz(graph), яка видаляє неінформативні частини лейблів, щоб вони не загромаджували візуалізацію.

### Завдання 1

Для того щоб побачити візуалізацію запустіть скрипт з ключем `-viz` або `--vizualization`
`python ./main.py -viz`

Для виведення короткого опису графу використовуйте ключ `-s` або `--statistic`
`python ./main.py -s`

### Завдання 2

Дерева, побудовані за допомогою алгоритмів BFS і DFS можна переглянути за допомогою команд `python ./main.py --bfs` і `python ./main.py --dfs` , відповідно.
Оскільки граф, у порівнянні із деревом, має надлишкові зв'язки, дерева, утворенні в наслідок обходу за різними алгоритмами включають тільки частину цих зв'язків і мають суттєво різну структуру. Однак, вузли обох дерев відповідають вузлам графа.

### Завдання 3

Хоча це не має особливого змісту, я додав до ребер графу певні ваги, на основі типу зв'язку, який вони позначають
```
DEPENDENCY_WEIGHTS = {
    'Requires': 1,
    'Wants': 3,
    'Before': 10,
    'After': 10,
    'Conflicts': 1000,
}
```
Тепер стає можливо виконувати задачі із пошуку оптимального шляху. Будемо шукати шлях до вузла `graphical.target`, що є останнім етапом запуску ОС.
`python ./main.py -d` або `python ./main.py --dijkstra`
Також ви можете передати назву вузла, шлях до якого шукаєте
`python ./main.py -d="initrd.target"`